{"./":{"url":"./","title":"首页","keywords":"","body":"欢迎来访，留个脚印吧~ var gitalk = new Gitalk({ \"clientID\": \"ebc418bb2f62d385ea9b\", \"clientSecret\": \"4ed34648983a156a67f51743c0c3a07704b4ecd8\", \"repo\": \"book\", \"owner\": \"LevisLv\", \"admin\": [\"LevisLv\"], id: decodeURI(location.pathname), perPage: 20, createIssueManually: true }); gitalk.render(\"gitalk-container\"); "},"JavaScript学习笔记/":{"url":"JavaScript学习笔记/","title":"JavaScript学习笔记","keywords":"","body":"注：此学习笔记均出自 廖雪峰的官方网站-JavaScript教程 JavaScript教程 这是小白的零基础JavaScript全栈教程。 JavaScript是世界上最流行的脚本语言，因为你在电脑、手机、平板上浏览的所有的网页，以及无数基于HTML5的手机App，交互逻辑都是由JavaScript驱动的。 简单地说，JavaScript是一种运行在浏览器中的解释型的编程语言。 那么问题来了，为什么我们要学JavaScript？尤其是当你已经掌握了某些其他编程语言如Java、C++的情况下。 简单粗暴的回答就是：因为你没有选择。在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。 Flash背后的ActionScript曾经流行过一阵子，不过随着移动应用的兴起，没有人用Flash开发手机App，所以它目前已经边缘化了。相反，随着HTML5在PC和移动端越来越流行，JavaScript变得更加重要了。并且，新兴的Node.js把JavaScript引入到了服务器端，JavaScript已经变成了全能型选手。 JavaScript一度被认为是一种玩具编程语言，它有很多缺陷，所以不被大多数后端开发人员所重视。很多人认为，写JavaScript代码很简单，并且JavaScript只是为了在网页上添加一点交互和动画效果。 但这是完全错误的理解。JavaScript确实很容易上手，但其精髓却不为大多数开发人员所熟知。编写高质量的JavaScript代码更是难上加难。 一个合格的开发人员应该精通JavaScript和其他编程语言。如果你已经掌握了其他编程语言，或者你还什么都不会，请立刻开始学习JavaScript，不要被Web时代所淘汰。 "},"JavaScript学习笔记/JavaScript简介/":{"url":"JavaScript学习笔记/JavaScript简介/","title":"JavaScript简介","keywords":"","body":"JavaScript简介 JavaScript历史 要了解JavaScript，我们首先要回顾一下JavaScript的诞生。 在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。 由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在两周之内设计出了JavaScript语言。你没看错，这哥们只用了10天时间。 为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。 ECMAScript 因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript标准。 所以简单说来就是，ECMAScript是一种语言标准，而JavaScript是网景公司对ECMAScript标准的一种实现。 那为什么不直接把JavaScript定为标准呢？因为JavaScript是网景的注册商标。 不过大多数时候，我们还是用JavaScript这个词。如果你遇到ECMAScript这个词，简单把它替换为JavaScript就行了。 JavaScript版本 JavaScript语言是在10天时间内设计出来的，虽然语言的设计者水平非常NB，但谁也架不住“时间紧，任务重”，所以，JavaScript有很多设计缺陷，我们后面会慢慢讲到。 此外，由于JavaScript的标准——ECMAScript在不断发展，最新版ECMAScript 6标准（简称ES6）已经在2015年6月正式发布了，所以，讲到JavaScript的版本，实际上就是说它实现了ECMAScript标准的哪个版本。 由于浏览器在发布时就确定了JavaScript的版本，加上很多用户还在使用IE6这种古老的浏览器，这就导致你在写JavaScript的时候，要照顾一下老用户，不能一上来就用最新的ES6标准写，否则，老用户的浏览器是无法运行新版本的JavaScript代码的。 不过，JavaScript的核心语法并没有多大变化。我们的教程会先讲JavaScript最核心的用法，然后，针对ES6讲解新增特性。 "},"JavaScript学习笔记/快速入门/":{"url":"JavaScript学习笔记/快速入门/","title":"快速入门","keywords":"","body":"快速入门 JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到中： alert('Hello, world'); ... 由...包含的代码就是JavaScript代码，它将直接被浏览器执行。 第二种方法是把JavaScript代码放到一个单独的.js文件，然后在HTML中通过引入这个文件： ... 这样，/static/js/abc.js就会被浏览器执行。 把JavaScript代码放入一个单独的.js文件中更利于维护代码，并且多个页面可以各自引用同一份.js文件。 可以在同一个页面中引入多个.js文件，还可以在页面中多次编写 js代码... ，浏览器按照顺序依次执行。 有些时候你会看到标签还设置了一个type属性： ... 但这是没有必要的，因为默认的type就是JavaScript，所以不必显式地把type指定为JavaScript。 如何编写JavaScript 可以用任何文本编辑器来编写JavaScript代码。这里我们推荐以下几种文本编辑器： Visual Studio Code 微软出的Visual Studio Code，可以看做迷你版Visual Studio，免费！跨平台！内置JavaScript支持，强烈推荐使用！ Sublime Text Sublime Text是一个好用的文本编辑器，免费，但不注册会不定时弹出提示框。 Notepad++ Notepad++也是免费的文本编辑器，但仅限Windows下使用。 注意：不可以用Word或写字板来编写JavaScript或HTML，因为带格式的文本保存后不是纯文本文件，无法被浏览器正常读取。也尽量不要用记事本编写，它会自作聪明地在保存UTF-8格式文本时添加BOM头。 如何运行JavaScript 要让浏览器运行JavaScript，必须先有一个HTML页面，在HTML页面中引入JavaScript，然后，让浏览器加载该HTML页面，就可以执行JavaScript代码。 你也许会想，直接在我的硬盘上创建好HTML和JavaScript文件，然后用浏览器打开，不就可以看到效果了吗？ 这种方式运行部分JavaScript代码没有问题，但由于浏览器的安全限制，以file://开头的地址无法执行如联网等JavaScript代码，最终，你还是需要架设一个Web服务器，然后以http://开头的地址来正常执行所有JavaScript代码。 不过，开始学习阶段，你无须关心如何搭建开发环境的问题，我们提供在页面输入JavaScript代码并直接运行的功能，让你专注于JavaScript的学习。 调试 俗话说得好，“工欲善其事，必先利其器。”，写JavaScript的时候，如果期望显示ABC，结果却显示XYZ，到底代码哪里出了问题？不要抓狂，也不要泄气，作为小白，要坚信：JavaScript本身没有问题，浏览器执行也没有问题，有问题的一定是我的代码。 如何找出问题代码？这就需要调试。 怎么在浏览器中调试JavaScript代码呢？ 首先，你需要安装Google Chrome浏览器，Chrome浏览器对开发者非常友好，可以让你方便地调试JavaScript代码。从这里下载Chrome浏览器。打开网页出问题的童鞋请移步国内镜像。 安装后，随便打开一个网页，然后点击菜单“查看(View)”-“开发者(Developer)”-“开发者工具(Developer Tools)”，浏览器窗口就会一分为二，下方就是开发者工具： 先点击“控制台(Console)“，在这个面板里可以直接输入JavaScript代码，按回车后执行。 要查看一个变量的内容，在Console中输入console.log(a);，回车后显示的值就是变量的内容。 关闭Console请点击右上角的“×”按钮。请熟练掌握Console的使用方法，在编写JavaScript代码时，经常需要在Console运行测试代码。 如果你对自己还有更高的要求，可以研究开发者工具的“源码(Sources)”，掌握断点、单步执行等高级调试技巧。 练习 打开新浪首页，然后查看页面源代码，找一找引入的JavaScript文件和直接编写在页面中的JavaScript代码。然后在Chrome中打开开发者工具，在控制台输入console.log('Hello');，回车查看JavaScript代码执行结果。 "},"JavaScript学习笔记/快速入门/基本语法/":{"url":"JavaScript学习笔记/快速入门/基本语法/","title":"基本语法","keywords":"","body":" 基本语法 语法 JavaScript的语法和Java语言类似，每个语句以;结束，语句块用{...}。但是，JavaScript并不强制要求在每个语句的结尾加;，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上;。 让JavaScript引擎自动加分号在某些情况下会改变程序的语义，导致运行结果与期望不一致。在本教程中，我们不会省略;，所有语句都会添加;。 例如，下面的一行代码就是一个完整的赋值语句： var x = 1; 下面的一行代码是一个字符串，但仍然可以视为一个完整的语句： 'Hello, world'; 下面的一行代码包含两个语句，每个语句用;表示语句结束： var x = 1; var y = 2; // 不建议一行写多个语句! 语句块是一组语句的集合，例如，下面的代码先做了一个判断，如果判断成立，将执行{...}中的所有语句： if (2 > 1) { x = 1; y = 2; z = 3; } 注意花括号{...}内的语句具有缩进，通常是4个空格。缩进不是JavaScript语法要求必须的，但缩进有助于我们理解代码的层次，所以编写代码时要遵守缩进规则。很多文本编辑器具有“自动缩进”的功能，可以帮助整理代码。 {...}还可以嵌套，形成层级结构： if (2 > 1) { x = 1; y = 2; z = 3; if (x y) { z = 5; } } JavaScript本身对嵌套的层级没有限制，但是过多的嵌套无疑会大大增加看懂代码的难度。遇到这种情况，需要把部分代码抽出来，作为函数来调用，这样可以减少代码的复杂度。 注释 以//开头直到行末的字符被视为行注释，注释是给开发人员看到，JavaScript引擎会自动忽略： // 这是一行注释 alert('hello'); // 这也是注释 另一种块注释是用/.../把多行字符包裹起来，把一大“块”视为一个注释： /* 从这里开始是块注释 仍然是注释 仍然是注释 注释结束 */ 练习： 分别利用行注释和块注释把下面的语句注释掉，使它不再执行： // 请注释掉下面的语句: alert('我不想执行'); alert('我也不想执行'); { const answer = ` // 请注释掉下面的语句: // alert('我不想执行'); /* alert('我也不想执行'); */ `; alert(answer); })();\">Show Answer 大小写 请注意，JavaScript严格区分大小写，如果弄错了大小写，程序将报错或者运行不正常。 "},"JavaScript学习笔记/快速入门/数据类型和变量/":{"url":"JavaScript学习笔记/快速入门/数据类型和变量/","title":"数据类型和变量","keywords":"","body":" 数据类型和变量 数据类型 计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在JavaScript中定义了以下几种数据类型： Number JavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型： 123; // 整数123 0.456; // 浮点数0.456 1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5 -99; // 负数 NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示 Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等，它们和十进制表示的数值完全一样。 Number可以直接做四则运算，规则和数学一致： 1 + 2; // 3 (1 + 2) * 5 / 2; // 7.5 2 / 0; // Infinity 0 / 0; // NaN 10 % 3; // 1 10.5 % 3; // 1.5 注意%是求余运算。 字符串 字符串是以单引号'或双引号\"括起来的任意文本，比如'abc'，\"xyz\"等等。请注意，''或\"\"本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。 布尔值 布尔值和布尔代数的表示完全一致，一个布尔值只有true、false两种值，要么是true，要么是false，可以直接用true、false表示布尔值，也可以通过布尔运算计算出来： true; // 这是一个true值 false; // 这是一个false值 2 > 1; // 这是一个true值 2 >= 3; // 这是一个false值 &&运算是与运算，只有所有都为true，&&运算结果才是true： true && true; // 这个&&语句计算结果为true true && false; // 这个&&语句计算结果为false false && true && false; // 这个&&语句计算结果为false ||运算是或运算，只要其中有一个为true，||运算结果就是true： false || false; // 这个||语句计算结果为false true || false; // 这个||语句计算结果为true false || true || false; // 这个||语句计算结果为true !运算是非运算，它是一个单目运算符，把true变成false，false变成true： ! true; // 结果为false ! false; // 结果为true ! (2 > 5); // 结果为true 布尔值经常用在条件判断中，比如： var age = 15; if (age >= 18) { alert('adult'); } else { alert('teenager'); } 比较运算符 当我们对Number做比较时，可以通过比较运算符得到一个布尔值： 2 > 5; // false 5 >= 2; // true 7 == 7; // true 实际上，JavaScript允许对任意数据类型做比较： false == 0; // true false === 0; // false 要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： NaN === NaN; // false 唯一能判断NaN的方法是通过isNaN()函数： isNaN(NaN); // true 最后要注意浮点数的相等比较： 1 / 3 === (1 - 2 / 3); // false 这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： Math.abs(1 / 3 - (1 - 2 / 3)) null和undefined null表示一个“空”的值，它和0以及空字符串''不同，0是一个数值，''表示长度为0的字符串，而null表示“空”。 在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。但是，在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。 JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 数组 数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如： [1, 2, 3.14, 'Hello', null, true]; 上述数组包含6个元素。数组用[]表示，元素之间用,分隔。 另一种创建数组的方法是通过Array()函数实现： new Array(1, 2, 3); // 创建了数组[1, 2, 3] 然而，出于代码的可读性考虑，强烈建议直接使用[]。 数组的元素可以通过索引来访问。请注意，索引的起始值为0： var arr = [1, 2, 3.14, 'Hello', null, true]; arr[0]; // 返回索引为0的元素，即1 arr[5]; // 返回索引为5的元素，即true arr[6]; // 索引超出了范围，返回undefined 对象 JavaScript的对象是一组由键-值组成的无序集合，例如： var person = { name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null }; JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为'Bob'，zipcode属性为null。 要获取一个对象的属性，我们用对象变量.属性名的方式： person.name; // 'Bob' person.zipcode; // null 变量 变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如： var a; // 申明了变量a，此时a的值为undefined var $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1 var s_007 = '007'; // s_007是一个字符串 var Answer = true; // Answer是一个布尔值true var t = null; // t的值是null 变量名也可以用中文，但是，请不要给自己找麻烦。 在JavaScript中，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次，例如： var a = 123; // a的值是整数123 a = 'ABC'; // a变为字符串 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下： int a = 123; // a是整数类型变量，类型用int申明 a = \"ABC\"; // 错误：不能把字符串赋给整型变量 和静态语言相比，动态语言更灵活，就是这个原因。 请不要把赋值语句的等号等同于数学的等号。比如下面的代码： var x = 10; x = x + 2; 如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。 要显示变量的内容，可以用console.log(x)，打开Chrome的控制台就可以看到结果。 // 打印变量x var x = 100; console.log(x); { const element = document.getElementById('log'); try { // 打印变量x var x = 100; console.log(x); element.classList.remove(['consoleError']); element.classList.add('consoleLog'); element.removeAttribute('hidden'); element.innerHTML = `${x}`; } catch (e) { element.classList.remove(['consoleLog']); element.classList.add('consoleError'); element.removeAttribute('hidden'); element.innerHTML = `${e}`; } })();\">Run 使用console.log()代替alert()的好处是可以避免弹出烦人的对话框。 strict模式 JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量： i = 10; // i现在是全局变量 在同一个页面的不同的JavaScript文件中，如果都不用var申明，恰好都使用了变量i，将造成变量i互相影响，产生难以调试的错误结果。 使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。 为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。 启用strict模式的方法是在JavaScript代码的第一行写上： 'use strict'; 这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。 来测试一下你的浏览器是否能支持strict模式： 'use strict'; // 如果浏览器支持strict模式， // 下面的代码将报ReferenceError错误: abc = 'Hello, world'; console.log(abc); { const element = document.getElementById('strictMode'); try { 'use strict'; // 如果浏览器支持strict模式， // 下面的代码将报ReferenceError错误: abc = 'Hello, world'; console.log(abc); element.classList.remove(['consoleError']); element.classList.add('consoleLog'); element.removeAttribute('hidden'); element.innerHTML = `${abc}`; } catch (e) { element.classList.remove(['consoleLog']); element.classList.add('consoleError'); element.removeAttribute('hidden'); element.innerHTML = `${e}`; } })();\">Run 运行代码，如果浏览器报错，请修复后再运行。如果浏览器不报错，说明你的浏览器太古老了，需要尽快升级。 不用var申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。我们在后面编写的JavaScript代码将全部采用strict模式。 "},"JavaScript学习笔记/快速入门/字符串/":{"url":"JavaScript学习笔记/快速入门/字符串/","title":"字符串","keywords":"","body":" 字符串 JavaScript的字符串就是用''或\"\"括起来的字符表示。 如果'本身也是一个字符，那就可以用\"\"括起来，比如\"I'm OK\"包含的字符是I，'，m，空格，O，K这6个字符。 如果字符串内部既包含'又包含\"怎么办？可以用转义字符\\来标识，比如： 'I\\'m \\\"OK\\\"!'; 表示的字符串内容是：I'm \"OK\"! 转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\表示的字符就是\\。 ASCII字符可以以\\x##形式的十六进制表示，例如： '\\x41'; // 完全等同于 'A' 还可以用\\u####表示一个Unicode字符： '\\u4e2d\\u6587'; // 完全等同于 '中文' 多行字符串 由于多行字符串用\\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 ... 表示： `这是一个 多行 字符串`; 注意：反引号在键盘的ESC下方，数字键1的左边： ┌─────┐ ┌─────┬─────┬─────┬─────┐ │ ESC │ │ F1 │ F2 │ F3 │ F4 │ └─────┘ └─────┴─────┴─────┴─────┘ ┌─────┬─────┬─────┬─────┬─────┐ │ ~ │ ! │ @ │ # │ $ │ │ ` │ 1 │ 2 │ 3 │ 4 │ ├─────┴──┬──┴──┬──┴──┬──┴──┬──┘ │ tab │ Q │ W │ E │ ├────────┴──┬──┴──┬──┴──┬──┘ │ caps lock │ A │ S │ └───────────┴─────┴─────┘ 练习：测试你的浏览器是否支持ES6标准，如果不支持，请把多行字符串用\\n重新表示出来： // 如果浏览器不支持ES6，将报SyntaxError错误: console.log(`多行 字符串 测试`); { const element = document.getElementById('multiLineString'); try { // 如果浏览器不支持ES6，将报SyntaxError错误: console.log(`多行\\n字符串\\n测试`); element.classList.remove(['consoleError']); element.classList.add('consoleLog'); element.removeAttribute('hidden'); element.innerHTML = `多行字符串测试`; } catch (e) { element.classList.remove(['consoleLog']); element.classList.add('consoleError'); element.removeAttribute('hidden'); element.innerHTML = `${e}`; } })();\">Run 模板字符串 要把多个字符串连接起来，可以用+号连接： var name = '小明'; var age = 20; var message = '你好, ' + name + ', 你今年' + age + '岁了!'; alert(message); 如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量： var name = '小明'; var age = 20; var message = `你好, ${name}, 你今年${age}岁了!`; alert(message); 练习：测试你的浏览器是否支持ES6模板字符串，如果不支持，请把模板字符串改为+连接的普通字符串： 'use strict'; // 如果浏览器支持模板字符串，将会替换字符串内部的变量: var name = '小明'; var age = 20; console.log(`你好, ${name}, 你今年${age}岁了!`); { const element = document.getElementById('templateString'); try { 'use strict'; // 如果浏览器支持模板字符串，将会替换字符串内部的变量: var name = '小明'; var age = 20; console.log(`你好, ${name}, 你今年${age}岁了!`); element.classList.remove(['consoleError']); element.classList.add('consoleLog'); element.removeAttribute('hidden'); element.innerHTML = `` + `你好, ${name}, 你今年${age}岁了!` + ``; } catch (e) { element.classList.remove(['consoleLog']); element.classList.add('consoleError'); element.removeAttribute('hidden'); element.innerHTML = `${e}`; } })();\">Run 操作字符串 字符串常见的操作如下： var s = 'Hello, world!'; s.length; // 13 要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始： var s = 'Hello, world!'; s[0]; // 'H' s[6]; // ' ' s[7]; // 'w' s[12]; // '!' s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined 需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果： var s = 'Test'; s[0] = 'X'; alert(s); // s仍然为'Test' JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串： toUpperCase toUpperCase()把一个字符串全部变为大写： var s = 'Hello'; s.toUpperCase(); // 返回'HELLO' toLowerCase toLowerCase()把一个字符串全部变为小写： var s = 'Hello'; var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lower lower; // 'hello' indexOf indexOf()会搜索指定字符串出现的位置： var s = 'hello, world'; s.indexOf('world'); // 返回7 s.indexOf('World'); // 没有找到指定的子串，返回-1 substring substring()返回指定索引区间的子串： var s = 'hello, world' s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello' s.substring(7); // 从索引7开始到结束，返回'world' "},"JavaScript学习笔记/快速入门/数组/":{"url":"JavaScript学习笔记/快速入门/数组/","title":"数组","keywords":"","body":" 数组 JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。 要取得Array的长度，直接访问length属性： var arr = [1, 2, 3.14, 'Hello', null, true]; arr.length; // 6 请注意，直接给Array的length赋一个新的值会导致Array大小的变化： var arr = [1, 2, 3]; arr.length; // 3 arr.length = 6; arr; // arr变为[1, 2, 3, undefined, undefined, undefined] arr.length = 2; arr; // arr变为[1, 2] Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array： var arr = ['A', 'B', 'C']; arr[1] = 99; arr; // arr现在变为['A', 99, 'C'] 请注意，如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化： var arr = [1, 2, 3]; arr[5] = 'x'; arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] 大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。 indexOf 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置： var arr = [10, 20, '30', 'xyz']; arr.indexOf(10); // 元素10的索引为0 arr.indexOf(20); // 元素20的索引为1 arr.indexOf(30); // 元素30没有找到，返回-1 arr.indexOf('30'); // 元素'30'的索引为2 注意了，数字30和字符串'30'是不同的元素。 slice slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C'] arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] 注意到slice()的起止参数包括开始索引，不包括结束索引。 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; var aCopy = arr.slice(); aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G'] aCopy === arr; // false push和pop push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： var arr = [1, 2]; arr.push('A', 'B'); // 返回Array新的长度: 4 arr; // [1, 2, 'A', 'B'] arr.pop(); // pop()返回'B' arr; // [1, 2, 'A'] arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次 arr; // [] arr.pop(); // 空数组继续pop不会报错，而是返回undefined arr; // [] unshift和shift 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： var arr = [1, 2]; arr.unshift('A', 'B'); // 返回Array新的长度: 4 arr; // ['A', 'B', 1, 2] arr.shift(); // 'A' arr; // ['B', 1, 2] arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次 arr; // [] arr.shift(); // 空数组继续shift不会报错，而是返回undefined arr; // [] sort sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序： var arr = ['B', 'C', 'A']; arr.sort(); arr; // ['A', 'B', 'C'] 能否按照我们自己指定的顺序排序呢？完全可以，我们将在后面的函数中讲到。 reverse reverse()把整个Array的元素给掉个个，也就是反转： var arr = ['one', 'two', 'three']; arr.reverse(); arr; // ['three', 'two', 'one'] splice splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle']; // 从索引2开始删除3个元素,然后再添加两个元素: arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite'] arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] // 只删除,不添加: arr.splice(2, 2); // ['Google', 'Facebook'] arr; // ['Microsoft', 'Apple', 'Oracle'] // 只添加,不删除: arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素 arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] concat concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array： var arr = ['A', 'B', 'C']; var added = arr.concat([1, 2, 3]); added; // ['A', 'B', 'C', 1, 2, 3] arr; // ['A', 'B', 'C'] 请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。 实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里： var arr = ['A', 'B', 'C']; arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] join join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： var arr = ['A', 'B', 'C', 1, 2, 3]; arr.join('-'); // 'A-B-C-1-2-3' 如果Array的元素不是字符串，将自动转换为字符串后再连接。 多维数组 如果数组的某个元素又是一个Array，则可以形成多维数组，例如： var arr = [[1, 2, 3], [400, 500, 600], '-']; 上述Array包含3个元素，其中头两个元素本身也是Array。 练习：如何通过索引取到500这个值： 'use strict'; var arr = [[1, 2, 3], [400, 500, 600], '-']; var x = ??; console.log(x); // x应该为500 { const answer = ` 'use strict'; var arr = [[1, 2, 3], [400, 500, 600], '-']; var x = arr[1][1]; console.log(x); // x应该为500 `; alert(answer); })();\">Show Answer 小结 Array提供了一种顺序存储一组元素的功能，并可以按索引来读写。 练习：在新生欢迎会上，你已经拿到了新同学的名单，请排序后显示：欢迎XXX，XXX，XXX和XXX同学！： 'use strict'; var arr = ['小明', '小红', '大军', '阿黄']; console.log('???'); { const answer = ` 'use strict'; var arr = ['小明', '小红', '大军', '阿黄']; console.log(\\`欢迎\\${arr.sort().slice(0, arr.length - 1).join('，')}和\\${arr.slice(arr.length - 1)}同学\\`);`; alert(answer); })();\">Show Answer "},"JavaScript学习笔记/快速入门/对象/":{"url":"JavaScript学习笔记/快速入门/对象/","title":"对象","keywords":"","body":" 对象 JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。 JavaScript的对象用于描述现实世界中的某个对象。例如，为了描述“小明”这个淘气的小朋友，我们可以用若干键值对来描述他： var xiaoming = { name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null }; JavaScript用一个{...}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。 上述对象申明了一个name属性，值是'小明'，birth属性，值是1990，以及其他一些属性。最后，把这个对象赋值给变量xiaoming后，就可以通过变量xiaoming来获取小明的属性了： xiaoming.name; // '小明' xiaoming.birth; // 1990 访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用''括起来： var xiaohong = { name: '小红', 'middle-school': 'No.1 Middle School' }; xiaohong的属性名middle-school不是一个有效的变量，就需要用''括起来。访问这个属性也无法使用.操作符，必须用['xxx']来访问： xiaohong['middle-school']; // 'No.1 Middle School' xiaohong['name']; // '小红' xiaohong.name; // '小红' 也可以用xiaohong['name']来访问xiaohong的name属性，不过xiaohong.name的写法更简洁。我们在编写JavaScript代码的时候，属性名尽量使用标准的变量名，这样就可以直接通过object.prop的形式访问一个属性了。 实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。 如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回undefined： 'use strict'; var xiaoming = { name: '小明' }; console.log(xiaoming.name); console.log(xiaoming.age); // undefined { const element = document.getElementById('undefined'); try { 'use strict'; var xiaoming = { name: '小明' }; console.log(xiaoming.name); console.log(xiaoming.age); // undefined element.classList.remove(['consoleError']); element.classList.add('consoleLog'); element.removeAttribute('hidden'); element.innerHTML = `小明undefined`; } catch (e) { element.classList.remove(['consoleLog']); element.classList.add('consoleError'); element.removeAttribute('hidden'); element.innerHTML = `${e}`; } })();\">Run 由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性： var xiaoming = { name: '小明' }; xiaoming.age; // undefined xiaoming.age = 18; // 新增一个age属性 xiaoming.age; // 18 delete xiaoming.age; // 删除age属性 xiaoming.age; // undefined delete xiaoming['name']; // 删除name属性 xiaoming.name; // undefined delete xiaoming.school; // 删除一个不存在的school属性也不会报错 如果我们要检测xiaoming是否拥有某一属性，可以用in操作符： var xiaoming = { name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null }; 'name' in xiaoming; // true 'grade' in xiaoming; // false 不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的： 'toString' in xiaoming; // true 因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。 要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法： var xiaoming = { name: '小明' }; xiaoming.hasOwnProperty('name'); // true xiaoming.hasOwnProperty('toString'); // false "},"JavaScript学习笔记/快速入门/循环/":{"url":"JavaScript学习笔记/快速入门/循环/","title":"循环","keywords":"","body":" 循环 循环 要计算1+2+3，我们可以直接写表达式： 1 + 2 + 3; // 6 要计算1+2+3+...+10，勉强也能写出来。 但是，要计算1+2+3+...+10000，直接写表达式就不可能了。 为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。 JavaScript的循环有两种，一种是for循环，通过初始条件、结束条件和递增条件来循环执行语句块： var x = 0; var i; for (i=1; i 让我们来分析一下for循环的控制条件： i=1 这是初始条件，将变量i置为1； i i++ 这是每次循环后的递增条件，由于每次循环后变量i都会加1，因此它终将在若干次循环后不满足判断条件i而退出循环。 练习 利用for循环计算1 2 3 ... 10的结果： 'use strict'; var x = ?; var i; for ... if (x === 3628800) { console.log('1 x 2 x 3 x ... x 10 = ' + x); } else { console.log('计算错误'); } { const answer = ` 'use strict'; var x = x; var 10; for (i = 1; i Show Answer for循环最常用的地方是利用索引来遍历数组： var arr = ['Apple', 'Google', 'Microsoft']; var i, x; for (i=0; i for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环： var x = 0; for (;;) { // 将无限循环下去 if (x > 100) { break; // 通过if判断来退出循环 } x ++; } for ... in for循环的一个变体是for ... in循环，它可以把一个对象的所有属性依次循环出来： var o = { name: 'Jack', age: 20, city: 'Beijing' }; for (var key in o) { console.log(key); // 'name', 'age', 'city' } 要过滤掉对象继承的属性，用hasOwnProperty()来实现： var o = { name: 'Jack', age: 20, city: 'Beijing' }; for (var key in o) { if (o.hasOwnProperty(key)) { console.log(key); // 'name', 'age', 'city' } } 由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引： var a = ['A', 'B', 'C']; for (var i in a) { console.log(i); // '0', '1', '2' console.log(a[i]); // 'A', 'B', 'C' } 请注意，for ... in对Array的循环得到的是String而不是Number。 while for循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的for循环容易让人看不清循环的逻辑，此时用while循环更佳。 while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现： var x = 0; var n = 99; while (n > 0) { x = x + n; n = n - 2; } x; // 2500 在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。 do ... while 最后一种循环是do { ... } while()循环，它和while循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件： var n = 0; do { n = n + 1; } while (n 用do { ... } while()循环要小心，循环体会至少执行1次，而for和while循环则可能一次都不执行。 练习 请利用循环遍历数组中的每个名字，并显示Hello, xxx!： 'use strict'; var arr = ['Bart', 'Lisa', 'Adam']; for ... 请尝试for循环和while循环，并以正序、倒序两种方式遍历。 { const answer = ` 'use strict'; var arr = ['Bart', 'Lisa', 'Adam']; // for循环正序 for (var i in arr.sort()) { console.log(\\`Hello, \\${arr[i]}!\\`); } // for循环倒序 for (var j in arr.sort().reverse()) { console.log(\\`Hello, \\${arr[j]}!\\`); } // while循环正序 var i = 0; while (i Show Answer 小结 循环是让计算机做重复任务的有效的方法，有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。JavaScript的死循环会让浏览器无法正常显示或执行当前页面的逻辑，有的浏览器会直接挂掉，有的浏览器会在一段时间后提示你强行终止JavaScript的执行，因此，要特别注意死循环的问题。 在编写循环代码时，务必小心编写初始条件和判断条件，尤其是边界值。特别注意i 和i 是不同的判断逻辑。 "},"JavaScript学习笔记/快速入门/Map和Set/":{"url":"JavaScript学习笔记/快速入门/Map和Set/","title":"Map和Set","keywords":"","body":" Map和Set JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。 但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。 为了解决这个问题，最新的ES6规范引入了新的数据类型Map。要测试你的浏览器是否支持ES6规范，请执行以下代码，如果浏览器报ReferenceError错误，那么你需要换一个支持ES6的浏览器： 'use strict'; var m = new Map(); var s = new Set(); console.log('你的浏览器支持Map和Set！'); // 直接运行测试 { const element = document.getElementById('supportMapAndSet'); try { 'use strict'; var m = new Map(); var s = new Set(); console.log('你的浏览器支持Map和Set！'); element.classList.remove(['consoleError']); element.classList.add('consoleLog'); element.removeAttribute('hidden'); element.innerHTML = `'你的浏览器支持Map和Set！'`; } catch (e) { element.classList.remove(['consoleLog']); element.classList.add('consoleError'); element.removeAttribute('hidden'); element.innerHTML = `${e}`; } })();\">Run Map Map是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array： var names = ['Michael', 'Bob', 'Tracy']; var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。 如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下： var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]); m.get('Michael'); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法： var m = new Map(); // 空Map m.set('Adam', 67); // 添加新的key-value m.set('Bob', 59); m.has('Adam'); // 是否存在key 'Adam': true m.get('Adam'); // 67 m.delete('Adam'); // 删除key 'Adam' m.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉： var m = new Map(); m.set('Adam', 67); m.set('Adam', 88); m.get('Adam'); // 88 Set Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： var s1 = new Set(); // 空Set var s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤： var s = new Set([1, 2, 3, 3, '3']); s; // Set {1, 2, 3, \"3\"} 注意数字3和字符串'3'是不同的元素。 通过addlete(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： s.add(4); s; // Set {1, 2, 3, 4} s.add(4); s; // 仍然是 Set {1, 2, 3, 4} 通过delete(key)方法可以删除元素： var s = new Set([1, 2, 3]); s; // Set {1, 2, 3} s.delete(3); s; // Set {1, 2} 小结 Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。 "},"JavaScript学习笔记/快速入门/Iterable/":{"url":"JavaScript学习笔记/快速入门/Iterable/","title":"Iterable","keywords":"","body":" Iterable 遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for ... of循环来遍历。 for ... of循环是ES6引入的新的语法，请测试你的浏览器是否支持： 'use strict'; var a = [1, 2, 3]; for (var x of a) { } console.log('你的浏览器支持for ... of'); // 请直接运行测试 { const element = document.getElementById('supportForOf'); try { 'use strict'; var a = [1, 2, 3]; for (var x of a) { } console.log('你的浏览器支持for ... of'); element.classList.remove(['consoleError']); element.classList.add('consoleLog'); element.removeAttribute('hidden'); element.innerHTML = `'你的浏览器支持for ... of'`; } catch (e) { element.classList.remove(['consoleLog']); element.classList.add('consoleError'); element.removeAttribute('hidden'); element.innerHTML = `${e}`; } })();\">Run 用for ... of循环遍历集合，用法如下： var a = ['A', 'B', 'C']; var s = new Set(['A', 'B', 'C']); var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]); for (var x of a) { // 遍历Array console.log(x); } for (var x of s) { // 遍历Set console.log(x); } for (var x of m) { // 遍历Map console.log(x[0] + '=' + x[1]); } 你可能会有疑问，for ... of循环和for ... in循环有何区别？ for ... in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。 当我们手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果： var a = ['A', 'B', 'C']; a.name = 'Hello'; for (var x in a) { console.log(x); // '0', '1', '2', 'name' } for ... in循环将把name包括在内，但Array的length属性却不包括在内。 for ... of循环则完全修复了这些问题，它只循环集合本身的元素： var a = ['A', 'B', 'C']; a.name = 'Hello'; for (var x of a) { console.log(x); // 'A', 'B', 'C' } 这就是为什么要引入新的for ... of循环。 然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例： 'use strict'; var a = ['A', 'B', 'C']; a.forEach(function (element, index, array) { // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index); }); { const element = document.getElementById('forEach'); try { 'use strict'; var a = ['A', 'B', 'C']; a.forEach(function (element, index, array) { // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index); }); element.classList.remove(['consoleError']); element.classList.add('consoleLog'); element.removeAttribute('hidden'); element.innerHTML = `A, index = 0B, index = 1C, index = 2`; } catch (e) { element.classList.remove(['consoleLog']); element.classList.add('consoleError'); element.removeAttribute('hidden'); element.innerHTML = `${e}`; } })();\">Run 注意，forEach()方法是ES5.1标准引入的，你需要测试浏览器是否支持。 Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身： var s = new Set(['A', 'B', 'C']); s.forEach(function (element, sameElement, set) { console.log(element); }); Map的回调函数参数依次为value、key和map本身： var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]); m.forEach(function (value, key, map) { console.log(value); }); 如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element： var a = ['A', 'B', 'C']; a.forEach(function (element) { console.log(element); }); "},"JavaScript学习笔记/函数/":{"url":"JavaScript学习笔记/函数/","title":"函数","keywords":"","body":"函数 我们知道圆的面积计算公式为： S = πr2 当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积： var r1 = 12.34; var r2 = 9.08; var r3 = 73.1; var s1 = 3.14 * r1 * r1; var s2 = 3.14 * r2 * r2; var s3 = 3.14 * r3 * r3; 当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 x x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。 有了函数，我们就不再每次写s = 3.14 x x，而是写成更有意义的函数调用s = area_of_circle(x)，而函数area_of_circle本身只需要写一次，就可以多次调用。 基本上所有的高级语言都支持函数，JavaScript也不例外。JavaScript的函数不但是“头等公民”，而且可以像变量一样使用，具有非常强大的抽象能力。 抽象 抽象是数学中非常常见的概念。举个例子： 计算数列的和，比如：1 + 2 + 3 + ... + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + ... + 100记作： 100 ∑n n=1 这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。 而且，这种抽象记法是可扩展的，比如： 100 ∑(n2+1) n=1 还原成加法运算就变成了： (1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1) 可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。 写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。 "},"JavaScript学习笔记/函数/函数定义和调用/":{"url":"JavaScript学习笔记/函数/函数定义和调用/","title":"函数定义和调用","keywords":"","body":" 函数定义和调用 定义函数 在JavaScript中，定义函数的方式如下： function abs(x) { if (x >= 0) { return x; } else { return -x; } } 上述abs()函数的定义如下： function指出这是一个函数定义； abs是函数的名称； (x)括号内列出函数的参数，多个参数以,分隔； { ... }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。 请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。 如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined。 由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量。 因此，第二种定义函数的方式如下： var abs = function (x) { if (x >= 0) { return x; } else { return -x; } }; 在这种方式下，function (x) { ... }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。 上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。 调用函数 调用函数时，按顺序传入参数即可： abs(10); // 返回10 abs(-9); // 返回9 由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数： abs(10, 'blablabla'); // 返回10 abs(-9, 'haha', 'hehe', null); // 返回9 传入的参数比定义的少也没有问题： abs(); // 返回NaN 此时abs(x)函数的参数x将收到undefined，计算结果为NaN。 要避免收到undefined，可以对参数进行检查： function abs(x) { if (typeof x !== 'number') { throw 'Not a number'; } if (x >= 0) { return x; } else { return -x; } } arguments JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array： 'use strict' function foo(x) { console.log('x = ' + x); // 10 for (var i=0; i { const element = document.querySelector('p#arguments'); try { 'use strict' function foo(x) { console.log('x = ' + x); // 10 for (var i=0; ix = 10arg 0 = 10arg 1 = 20arg 2 = 30`; } catch (e) { element.classList.remove(['consoleLog']); element.classList.add('consoleError'); element.removeAttribute('hidden'); element.innerHTML = `${e}`; } })();\">Run 利用arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值： function abs() { if (arguments.length === 0) { return 0; } var x = arguments[0]; return x >= 0 ? x : -x; } abs(); // 0 abs(10); // 10 abs(-9); // 9 实际上arguments最常用于判断传入参数的个数。你可能会看到这样的写法： // foo(a[, b], c) // 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null： function foo(a, b, c) { if (arguments.length === 2) { // 实际拿到的参数是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 } // ... } 要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。 rest参数 由于JavaScript函数允许接收任意个参数，于是我们就不得不用arguments来获取所有参数： function foo(a, b) { var i, rest = []; if (arguments.length > 2) { for (i = 2; i 为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？ ES6标准引入了rest参数，上面的函数可以改写为： function foo(a, b, ...rest) { console.log('a = ' + a); console.log('b = ' + b); console.log(rest); } foo(1, 2, 3, 4, 5); // 结果: // a = 1 // b = 2 // Array [ 3, 4, 5 ] foo(1); // 结果: // a = 1 // b = undefined // Array [] rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。 如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。 因为rest参数是ES6新标准，所以你需要测试一下浏览器是否支持。请用rest参数编写一个sum()函数，接收任意个参数并返回它们的和： 'use strict'; function sum(...rest) { ??? } // 测试: var i, args = []; for (i=1; i { const answer = ` 'use strict'; function sum(...rest) { let result = 0; if (Array.isArray(rest)) { rest.forEach((item) => { result += item; }); } return result; } `; alert(answer); })();\">Show Answer 小心你的return语句 前面我们讲到了JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑： function foo() { return { name: 'foo' }; } foo(); // { name: 'foo' } 如果把return语句拆成两行： function foo() { return { name: 'foo' }; } foo(); // undefined 要小心了，由于JavaScript引擎在行末自动添加分号的机制，上面的代码实际上变成了： function foo() { return; // 自动添加了分号，相当于return undefined; { name: 'foo' }; // 这行语句已经没法执行到了 } 所以正确的多行写法是： function foo() { return { // 这里不会自动加分号，因为{表示语句尚未结束 name: 'foo' }; } 练习 定义一个计算圆面积的函数area_of_circle()，它有两个参数： r: 表示圆的半径； pi: 表示π的值，如果不传，则默认3.14 'use strict'; function area_of_circle(r, pi) { return 0; } // 测试: if (area_of_circle(2) === 12.56 && area_of_circle(2, 3.1416) === 12.5664) { console.log('测试通过'); } else { console.log('测试失败'); } { const answer = ` 'use strict'; function area_of_circle(r, pi) { pi = pi ? pi : 3.14; return pi * r * r; } `; alert(answer); })();\">Show Answer 小明是一个JavaScript新手，他写了一个max()函数，返回两个数中较大的那个： 'use strict'; function max(a, b) { if (a > b) { return a; } else { return b; } } console.log(max(15, 20)); { const element = document.getElementById('max'); try { 'use strict'; function max(a, b) { if (a > b) { return a; } else { return b; } } console.log(max(15, 20)); element.classList.remove(['consoleError']); element.classList.add('consoleLog'); element.removeAttribute('hidden'); element.innerHTML = `${max(15, 20)}`; } catch (e) { element.classList.remove(['consoleLog']); element.classList.add('consoleError'); element.removeAttribute('hidden'); element.innerHTML = `${e}`; } })();\">Run { const answer = ` 'use strict'; function max(a, b) { if (a > b) { return a; } else { return b; } } `; alert(answer); })();\">Fix 但是小明抱怨他的浏览器出问题了，无论传入什么数，max()函数总是返回undefined。请帮他指出问题并修复。 "}}